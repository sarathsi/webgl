<!DOCTYPE html>
<html>
<body>
<canvas id="c" width="400" height="400"></canvas>
<script>
const gl = document.getElementById("c").getContext("webgl2");
if (!gl) { alert("WebGL2 not supported"); throw ""; }

// ---------- shaders ----------
const vs = `#version 300 es
layout(location = 0) in vec2 pos;
void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
}`;
const fs = `#version 300 es
#extension GL_OES_sample_variables : require
precision highp float;
out vec4 color;
uint popcount(uint v) {
    uint c = 0u;
    for (; v != 0u; v >>= 1) c += v & 1u;
    return c;
}
void main() {
    //float r = float(popcount(uint(gl_SampleMaskIn[0])));
    flost r = 16.0
    color = vec4(r * 4.0 / 255.0, 0.0, 0.0, 1.0);
}`;

// ---------- compile / program ----------
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}
const program = gl.createProgram();
gl.attachShader(program, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS))
  throw gl.getProgramInfoLog(program);
gl.useProgram(program);

// ---------- geometry (triangle) ----------
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array([-1,1,  1,-1,  -1,-1]),
  gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

// ---------- test helper ----------
function runTest(sampleCount, enableCoverage, coverage) {
  if (enableCoverage) gl.enable(gl.SAMPLE_COVERAGE);
  else gl.disable(gl.SAMPLE_COVERAGE);
  gl.sampleCoverage(coverage, false);

  const rbo = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);
  gl.renderbufferStorageMultisample(gl.RENDERBUFFER,
    sampleCount, gl.RGBA8, 32, 32);

  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, rbo);

  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fbo);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 3);

  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo);
  const p = new Uint8Array(4);
  gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, p);
  const actual = p[0];

  // Expected (same formula as conformance suite)
  let expected = Math.max(sampleCount, 1) * 4;
  if (enableCoverage && sampleCount > 0)
    expected *= coverage * coverage;

  const ok = Math.abs(actual - expected) <= 2;
  console.log(`${ok ? "PASS" : "FAIL"} | Samples=${sampleCount}, coverageEnabled=${enableCoverage}, coverage=${coverage} | Actual=${actual}, Expected=${expected}`);
}

// ---------- enumerate sample counts ----------
const sampleCounts = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
sampleCounts.push(0); // emulate single-sample

// ---------- run all combinations ----------
for (const sc of sampleCounts) {
  if (sc > 32) continue;
  for (const enable of [false, true]) {
    for (const cv of [0.0, 0.5, 1.0]) {
      if (sc == 1 && cv != 0.0 && cv != 1.0) continue;
      runTest(sc, enable, cv);
    }
  }
}
alert("Done â€” see console for PASS/FAIL results");
</script>
</body>
</html>
